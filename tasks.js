var fs = require('fs');



var loadJSON = function(fn) {
	return JSON.parse(fs.read(fn));
};



var saveJSON = function(fn, o) {
	fs.write(fn, JSON.stringify(o), 'w');
};



var now = function() {
	return new Date().valueOf();
};



var randomInt = function(n) {
	return ~~( Math.random() * n);
};


var randomItemOfArray = function(arr) {
	return arr[ randomInt(arr.length) ];
};



var getUrl = function(cfg, channelName) {
	return 'https://' + cfg.slackInstance + '.slack.com/messages/' + channelName + '/';
};



var login = function(page, cfg) {
	return page.evaluate(
		function(cfg) {
			if (!document.querySelector('#email')) { return 'failed'; }
			document.querySelector('#email'   ).value = cfg.email;
			document.querySelector('#password').value = cfg.password;
			document.querySelector('#signin_btn').click();
		},
		cfg
	);
};



var sendMessage = function(page, msg) {
	var res = page.evaluate(
		function(msg) {
			var inputEl = document.querySelector('#message-input');
			if (!inputEl) { return 'failed'; }
			inputEl.focus();
			inputEl.value = msg;
		},
		msg
	);

	page.sendEvent('keyup',   page.event.key.Enter, null, null, 0);
	page.sendEvent('keydown', page.event.key.Enter, null, null, 0);

	return res;
};



var getMessages = function(page, currentChannelLTS) {
	return page.evaluate(
		function(currentChannelLTS) {
			var arr = document.querySelectorAll('.message_content');
			var when, el, i, arr2 = [];

			for (i = arr.length - 1; i >= 0; --i) {
				el = arr[i];
				when = parseFloat( el.parentNode.getAttribute('data-ts') );
				if (when === currentChannelLTS) { break; }
				arr2.unshift({
					//id:   el.parentNode.getAttribute('id').substring(4), // removes msg_ prefix
					text: el.textContent.trim().replace(/\n?\t+.*/, ''), // removes autogenerated content?
					from: el.parentNode.querySelector('[target]').getAttribute('href').split('/').pop(),
					when: when
				});
			}
			return arr2;
		},
		currentChannelLTS
	);
};



var updateChannel = function(page, lastChannelTimestamps, currentChannel, onNewMessage) {
	var currentChannelLTS = lastChannelTimestamps[currentChannel] || undefined;

	var messages = getMessages(page, currentChannelLTS);

	if (messages.length) {
		console.log('fetched new ' + messages.length + ' messages from channel ' + currentChannel + '.');

		messages.forEach(function(msg) { // enrich messages with channel field
			msg.channel = currentChannel;
		});

		messages.forEach(function(msg) { // notify consumers
			onNewMessage(msg);
		});

		// save last ts for channel
		currentChannelLTS = messages[messages.length - 1].when;
		lastChannelTimestamps[currentChannel] = currentChannelLTS;

		//console.log('saving ts ' + currentChannelLTS + ' for channel ' + currentChannel);
		saveJSON('lastChannelTimestamps.json', lastChannelTimestamps);
	}
};
