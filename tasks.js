var fs = require('fs');



var loadJSON = function(fn) {
	return JSON.parse(fs.read(fn));
};



var saveJSON = function(fn, o) {
	fs.write(fn, JSON.stringify(o), 'w');
};



var randomInt = function(n) {
	return ~~( Math.random() * n);
};


var randomItemOfArray = function(arr) {
	return arr[ randomInt(arr.length) ];
};



var getUrl = function(cfg, channelName) {
	return 'https://' + cfg.slackInstance + '.slack.com/messages/' + channelName + '/';
};



var login = function(page, cfg) {
	return page.evaluate(
		function(cfg) {
			if (!document.querySelector('#email')) { return 'failed'; }
			document.querySelector('#email'   ).value = cfg.email;
			document.querySelector('#password').value = cfg.password;
			document.querySelector('#signin_btn').click();
		},
		cfg
	);
};



var sendMessage = function(page, msg) {
	var res = page.evaluate(
		function(msg) {
			var inputEl = document.querySelector('#message-input');
			if (!inputEl) { return 'failed'; }
			inputEl.focus();
			inputEl.value = msg;
		},
		msg
	);

	page.sendEvent('keyup',   page.event.key.Enter, null, null, 0);
	page.sendEvent('keydown', page.event.key.Enter, null, null, 0);

	return res;
};



var getMessages = function(page, afterId) {
	var res = page.evaluate(
		function(afterId) {
			var debug = 'Received ' + afterId + '. ';

			var arr = document.querySelectorAll('.message_content');
			arr = Array.prototype.slice.call(arr);

			// DOM to JSON
			arr = arr.map(function(el) {
				return {
					id:   el.parentNode.getAttribute('id').substring(4), // removes msg_ prefix
					text: el.textContent.trim().replace(/\n?\t+.*/, ''), // removes autogenerated content?
					from: el.parentNode.querySelector('[target]').getAttribute('href').split('/').pop(),
					when: parseFloat( el.parentNode.getAttribute('data-ts') ) // timestamp
				};
			});

			// looks for afterId
			var found = false;
			var l = arr.length;
			for (var i = l - 1; i >= 0; --i) {
				if (arr[i].id === afterId) {
					found = true;
					break;
				}
			}

			// if found, remove
			if (found) {
				arr = arr.splice(i + 1, l);
				debug += 'Found ' + l + ' messages. Returning ' + arr.length + ' messages because afterId was found at position #' + i + '. ';
			}
			else {
				debug += 'Found ' + arr.length + ' messages. All returned because afterId was not found. ';
			}

			return {newMessages:arr, debug:debug};
		},
		afterId
	);

	// console.log(res.debug);

	return res.newMessages;
};



var updateChannel = function(page, channelMessages, currentChannel, onNewMessage) {
	var currentChannelMessages = channelMessages[currentChannel] || [];

	var afterId;
	if (currentChannelMessages.length > 0) {
		afterId = currentChannelMessages[ currentChannelMessages.length-1 ].id;
	}

	var messages = getMessages(page, afterId);
	console.log('fetched new ' + messages.length + ' messages from channel ' + currentChannel + '.');

	messages.forEach(function(msg) {
		onNewMessage(msg);
	});

	currentChannelMessages = currentChannelMessages.concat(messages);

	// TODO have max length?

	saveJSON(currentChannel + '.json', currentChannelMessages);
	console.log('saved ' + currentChannelMessages.length + ' messages.');

	channelMessages[currentChannel] = currentChannelMessages;
};
